# プロジェクトの問題点 (Project Issues)

このドキュメントは、`HmChatGptWeb` プロジェクトのコードベースを分析した結果、特定された潜在的な問題点をまとめたものです。

## 1. UIオートメーションへの強い依存による脆弱性

このプロジェクトは、Webブラウザ上の操作を自動化するために、キーボード入力のシミュレーション (`keybd_event`) や、一定時間の待機 (`setTimeout`) に大きく依存しています。

- **問題点**:
  - `chatgpt.com` のウェブサイトのHTML構造、CSS、またはJavaScriptが変更されると、マクロが意図通りに動作しなくなる可能性が非常に高いです。例えば、`#prompt-textarea` のような要素のIDが変更されただけで、プロンプトの入力が失敗します。
  - 通信速度やPCの負荷によってウェブページの応答時間が変わると、固定時間 (`300ms` など) の待機では不十分、または長すぎる場合があり、処理の失敗に繋がります。
  - コメントに「ChatGptのサイトに限っては、900以上の幅があることが必要」とあるように、特定の画面レイアウトに依存しているため、非常に壊れやすい（brittle）です。

## 2. 存在しない関数の呼び出しによる実行時エラー

`HmChatGptWeb.mac` の中で、`com.SendShiftEscSync()` という関数が呼び出されています。

- **問題点**:
  - この `SendShiftEscSync` というメソッドは、C#のCOMコンポーネント (`HmChatGptWeb.cs`) 内に実装されていません。
  - そのため、このマクロを実行すると、該当箇所で未定義のメソッドを呼び出そうとし、実行時エラーが発生します。これは明らかなバグです。

## 3. C#における `async void` の多用によるエラー処理の問題

C#のCOMコンポーネントでは、`async void` を持つメソッドが複数定義されています。

- **問題点**:
  - `async void` メソッド内で発生した例外は、呼び出し元で `try-catch` することができず、捕捉されない例外として扱われます。
  - これにより、予期せぬエラーが発生した場合にアプリケーション全体がクラッシュする可能性があり、デバッグも困難になります。`async Task` を返し、呼び出し元で `await` するのが推奨される設計です。

## 4. 複雑で保守が困難なコード構造

プロジェクトのロジックは、以下の3つの異なるファイル・言語にまたがって実装されており、相互に強く依存しています。

1.  `HmChatGptWeb.mac` (秀丸マクロ)
2.  `HmConvAIWeb.js` (JavaScriptライブラリ)
3.  `HmChatGptWeb.cs` (C# COMコンポーネント)

- **問題点**:
  - `eval()` を使ってJavaScriptファイルを読み込んだり、秀丸の `setstaticvariable` 機能でグローバルな状態を共有したりしており、処理の流れを追うのが困難です。
  - 機能の追加や修正を行う際に、複数のファイルを同時に編集する必要があり、意図しない副作用（サイドエフェクト）を生みやすい構造になっています。
  - デバッグを行う際も、どの部分で問題が発生しているのかを特定するのが難しく、保守性が低いと言えます。

## 5. 外部実行ファイルへの依存

このツールは、`ClipboardHistMngr.exe` と `HmFocusEachBrowserInputField.exe` という2つの外部実行可能ファイルに依存しています。

- **問題点**:
  - これらの実行ファイルのソースコードは、別のGitHubリポジトリで管理されており、このプロジェクトには含まれていません。
  - ユーザーがこれらのファイルを正しい場所に配置しなかった場合や、バージョン互換性のないものが使われた場合に、ツールは正常に機能しません。依存関係がプロジェクト内で完結していないため、配布や管理が煩雑になります。

## 6. 限定的なURLクエリ注入

初回の質問のみ、URLのクエリパラメータ (`?q=...`) を使ってChatGPTにプロンプトを渡す、という賢い実装がされています。

- **問題点**:
  - この方法は最初の1回しか機能せず、2回目以降の対話はすべて、前述の脆弱なUIオートメーションに頼らざるを得ません。
  - APIを利用していないための制約ですが、このハイブリッドなアプローチが、かえってコードの複雑性を増している一因にもなっています。
